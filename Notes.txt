
_____________________________________________________________________________________________________
## 1 - Creating a new App
Vamos usar o rails 7.0.8 e o Ruby 3.2.0
Criando o projeto 
  `rails new blog_gorails` 
Rodando o projeto
  `rails s`
_____________________________________________________________________________________________________
## 2 - The MVC Pattern Explained
_____________________________________________________________________________________________________
## 3 - Rails Application Structure Explained
_____________________________________________________________________________________________________
## 4 - Creating A Blog Post Model

Para criar o model do post chamado BlogPost
  `rails generate model BlogPost title:string body:text`

  Ele vai criar o arquivo blog_post.rb em models
  este arquivo possui uma classe chamada BlogPost que herda de ApplicationRecord

Em db/migrate tem um arquivo para criação da tabela para quando o comando migrate for solicitado.

Agora rodamos o comando para criação da tabela.
  `rails db:migrate`

Uma vez criada a tabela podemos consultar seus dados por meio de um programa externo. 
Eu usei o tableplus https://tableplus.com/

Podemos rodar o console para consulta do bd também;
`rails console`
`BlogPost.all`
Por enquanto não teremos nada inserido. Então vamos INSERIR um primeiro dado:

`BlogPost.create(title: "Hello world", body: "This is my very first blog post")`

Agora temos o dado inserido no banco de dados e um objeto ruby que contem os dados.
Podemos CONSULTAR os dados com os comandos:
`BlogPost.all`
`BlogPost.find(1)` onde 1 é o id do objeto.

Podemos salvar esse objeto em uma variável e usar o comando UPDATE (do activerecord) para alterar dados.
`post = BlogPost.find(1)`
`post.update(title: 'Updated title')`

Podemos usar o comando DESTROY (do activerecord) para APAGAR dados.
`post.destroy`

_____________________________________________________________________________________________________
## 5 - Adding a Blog Index Action

Uma página de índice nos permite exibir todas as postagens do blog em nosso banco de dados. 
Aprenderemos como configurar rotas que apontam para controladores e ações que renderizam HTML.

Dentro de config/routes.rb definiremos os caminhos
root que é a rota principal '/'

Rails.application.routes.draw do
  # Defines the root path route ('/') do lado esquerdo temos o nome do cotroller e do direito temos o action
  root "blog_posts#index"
end

Ainda não vai funcionar pois o controller não foi criado e direcionado. Faremos o seguinte
CRIAÇÃO DO CONTROLLER

Criaremos o arquivo  app/controllers/blog_posts_controller.rb (atenção para as letras maiúsculas e minúsculas)
Toda vez que definimos um arquivo no rails, criamos uma classe que combina com o nome do arquivo:
blog_posts_controller.rb ----> class BlogPostController

Essa classe vai herdar de ApplicationController que vai ter todos os aparatos para http requests, parameters, responses ...

Vamos adicionar um método chamado index (mesmo se esse método esteja vazio, o rails procura em views uma pasta com o nome que combine procurando o arquivo correspondente) 
e precisamos agora de um template no formato text/html. 
Esse TEMPLATE dentro da pasta VIEWS vai ser crido dentro em views/blog_posts/index.html.erb
Dentro desse arquivo colocamos os códigos html. 
Aqui podemos usar um template para usar códigos ruby. `<%= %>` ou `<% %>` onde o que possui '=' é para prints na tela

Em blog_posts_controller.rb, no método index, vamos criar uma variável '@' que vai possuir todos os posts. Assim podemos usar ela no view.
  `@blog_posts = BlogPost.all`
Usamos ele no blog_posts/index.html.erb
    `<h1>My blog<h1>

  <% @blog_posts.each do |blog_post| %>
    <h2><%= blog_post.title %></h2>
    <%= blog_post.body %>
  <% end %>
`
__________________________________________________________________________________________________________________________________________________________________________________________________________
## 6 - Adding a Blog Post Show Action

Agora vamos tornar os títulos de cada post 'clicável' para podermos acessar cada post separadamente em página.
Entraremos agora nos GET, POST, PUT, PATCH e DELETE.

Dentro do arquivo routes.rb vamos criar a seguinte rota
`get "/blog_posts/:id", to: "blog_posts#show` 
Aqui o rails vai entender o :id como uma variável com qualquer caractere (menos o '/') e vai ser enviado como PARAMS
ele vai fazer essa requisição para o controller#show, onde show será um método que irá procurar o post pelo :id, criaremos esse método

`
def show
    @blog_post = BlogPost.find(params[:id])
  end
`
Aqui o params é fornecido pelo ApplicationController que vai auxiliar na busca do elemento no banco de dados.
Temos que ter uma view para essa rota, assim como o index, vamos criar dentro de blog_posts um arquivo chamado show.html.erb que vai exibir o único post

<h1><%= @blog_post.title %><h1>
<h3><%= @blog_post.body %></h3>

Quando acessamos a url http://127.0.0.1:3000/blog_posts/1 , ele vai rotear para blog_posts passando como parâmetro 1. O blog_posts_controller vai buscar o post
com id = 1 e exibir em show.
Caso ele não encontre o post com id informado, vai gerar um erro (ActiveRecord::RecordNotFound), vamos tratar essa excessão em blog_posts_controller:

rescue ActiveRecord::RecordNotFound
    redirect_to root_path
  end

Onde root_path é um método que chama o caminho raiz ("blog_posts#index") ou simplesmente '/'. Abordaremos isso adiante.

Agora vamos tornar os títulos links para o post. Faremos isso em app/views/blog_posts/index.html.erb usando o LINK_TO
    link_to "text to display" , "rota do link"
no nosso caso no arquivo ficaria assim.
    <h2><%= link_to blog_post.title, "/blog_posts/#{blog_post.id}" %></h2>
Mas essa não é a maneira certa de fazer referência ao link, pois se quisermos mudar o nome /blog_posts teríamos que fazer em todos os lugares onde usamos a rota.
Para isso, em rotas podemos dar um 'apelido' para essa rota e usar esse apelido ao invés do caminho. Para criar esse apelido em /routes.rb usamos o ,as: :apelido
get "/blog_posts/:id", to: "blog_posts#show", as: :blog_post

E para usar ele no link usamos assim: 
   apelido_path(parametro) ou  apelido_url(parametro)
no nosso caso no arquivo ficaria assim.
   <h2><%= link_to blog_post.title, blog_post_path(blog_post.id) %></h2>

Para SIMPLIFICAR mais ainda, podemos usar desse jeito

   <h2><%= link_to blog_post.title, blog_post %></h2>
Aqui ele já vai inferir que você quer o link blog_post e por meio do objeto citado ele já procura com o id.
Isso é ajudado pelo sistema de nomes que o rails atribui para o model. Se executarmos `BlogPost.model_name` poderemos verificar os nomes que o rails usa para o modelo


__________________________________________________________________________________________________________________________________________________________________________________________________________
## 7 - Adding a New Blog Post Action

Criaremos uma nova rota em routes.rb
    get "/blog_posts/new", to: "blog_posts#new", as: :new_blog_post
OBS: Essa rota ficará acima da rota existente (show) pois o rails busca as rotas em sequência, se ele encontrar a primeira rota o show, ele vai acessá-la usando o new como um parâmetro,
como ele não vai achar um post com id 'new', ele vai nos redirecionar para a página index.

Uma vez criada essa rota, criaremos o arquivo correspondente em views/blog_posts, chamado new.html.erb (obs: no nome do arquivo usa-se '.' e não '_')

Vamos criar o método para adicionar um novo post em blog_posts_controller#new
Aqui dentro vamos instanciar um objeto 
`@blog_post = BlogPost.new `
Quando instanciamos esse objeto, ele não é salvo no banco de dados. Com ele podemos criar um FORM na página específica da seguinte maneira.

        <%= form_with model: @blog_post do |form|%>
          <div>
            <%= form.label :title %>
            <%= form.text_field :title %>
          </div>
          <div>
            <%= form.label :body %>
            <%= form.text_area :body %>
          </div>
          <%= form.button %>
        <% end %>

Uma vez criado esse formulário, podemos agora criar a rota POST para usar esses parametros e criar o objeto no bd. Em routes.rb faremos essa rota.

  post "/blog_posts", to: "blog_posts#create", as: :blog_posts

Próximo passo agora é criar o método create no blog_posts_controller.rb

__________________________________________________________________________________________________________________________________________________________________________________________________________
## 8 - Creating New Blog Posts

Criamos o método blog_posts_controller#create para tratar dos params recebidos do FORM. Poderíamos criar um objeto BlogPost da seguinte maneira:
  `@blog_post = BlogPost.new(params[:blog_post])` mas o rails não passar os params diretamente para o database para evitar alterações ilícitas de dados. Logo faremos a adição 
  da seguinte maneira:

  Criaremos um método PRIVADO para tratar desses PARAMS. Esse método vai retornar os parâmetros permitidos.

          private 
          def blog_post_params
            params.(:blog_post).permit(:title, :body)
          end

E no método create devemos verificar se o post foi salvo corretamente no banco de dados.

        def create
            @blog_post = BlogPost.new(blog_post_params)
            if @blog_post.save
              redirect_to @blog_post
            else
              render :new, status: :unprocessable_entity
            end
          end

Se salvar direciona para @blog_post
Caso não salve por falta de dados ele renderiza a página new, manda o status de erro para o navegador,
ao renderizar a página new, ele mantem o objeto que lá já estava e o objeto agora carrega com ele o erro que ocorreu,
os campos preenchidos do formulário permanecem preenchidos.

Para validarmos o model para não receber campos em branco, modificaremos o arquivo models/blog_post.rb da seguinte maneira

          class BlogPost < ApplicationRecord
            validates :title, presence: true
            validates :body, presence: true
          end

Agora o blog_post só será salvo se os campos estiverem preenchidos.
No caso de não for salvo, podemos mostrar a mensagem de erro para o usuário na tela de formulário renderizada:

          <%= form_with model: @blog_post do |form|%>
            <%if form.object.errors.any? %>
              <div>
                <% form.object.errors.full_messages.each do |message| %>
                    <div><%= message %></div>
                  <% end %>
              </div>
            <% end %>
            ...

Vai mostrar as mensagens que os campos não podem ficar em branco.
Caso não haja erros e o post seja criado, ele vai redirecionar para o objeto criado em:
          if @blog_post.save      
                redirect_to @blog_post
Ao usar @blog_post, ele redireciona para o post usando o id do post criado. Coisas do rails.

__________________________________________________________________________________________________________________________________________________________________________________________________________
## 9 - Edit & Update Blog Post Actions

Vamos criar a rota para editar o post. Lembrando que a rota será criada em route.rb e deve-se colocar de maneira
que os dados da rota não sejam confundidos com parâmetros, por isso ela deve ficar antes do show:
      `get "/blog_posts/:id/edit", to: "blog_posts#edit", as: :edit_blog_post`

Seguiremos os mesmos passos das rotas anteriores, criando o método blog_posts_controller#edit e o arquivo
views/blog_posts/edit.html.erb

Agora vamos gerar o mesmo formulário para o post solicitado. Esse formulário é exatamente igual ao do new, então podemos
usá-lo copiando. Mas nesse caso vamos criar um PARTIAL que será usado em ambos.
Em rails os partials são nomeados precedidos de '_'. então dentro de views/blog_posts criaremos um arquivo chamado
_form.html.erb e para usar ele dentro das views fazemos o seguinte:

          <%= render partial: 'form', locals: {blog_post: @blog_post} %>


se vai usar esse partial você deve informar diretamente a variável blog_post que será usada.